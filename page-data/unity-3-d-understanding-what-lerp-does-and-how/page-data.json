{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/unity-3-d-understanding-what-lerp-does-and-how","result":{"data":{"post":{"__typename":"MdxPost","slug":"/unity-3-d-understanding-what-lerp-does-and-how","title":"Unity3D- Understanding what Lerp does and how","date":"10.10.2018","tags":[{"name":"Programming","slug":"programming"},{"name":"Unity3D","slug":"unity-3-d"},{"name":"C#","slug":"c"},{"name":"game-dev","slug":"game-dev"},{"name":"maths","slug":"maths"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unity3D- Understanding what Lerp does and how\",\n  \"date\": \"2018-10-10T00:00:00.000Z\",\n  \"tags\": [\"Programming\", \"Unity3D\", \"C#\", \"game-dev\", \"maths\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Why do we need Lerp in the first place\"), mdx(\"p\", null, \"Linear Interpolation or Lerping is a way to change value smoothly over time between two values. You might say i can do that by chaging the value by a certain speed by taking into account the deltaTime in the Update/FixedUpdate loop so why bother using the Lerp API. Additionally you might say we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transform.MoveTowards\"), \" API. And yes you are correct if you want the movement to have constant velocity and dont want to have any damping or smoothness or ease applied.\"), mdx(\"p\", null, \"Ex: Moving a object and bring to halt smoothly but not abruptly.\"), mdx(\"p\", null, \"Here is an example of a game i am working on with and without Lerp.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Without Lerp\"), \": Notice how the new ball and the balls behind it are shifted instantly.\"), mdx(\"iframe\", {\n    src: \"https://gfycat.com/ifr/FoolishWhoppingBobolink\",\n    width: \"950px\",\n    height: \"500px\",\n    frameBorder: \"0\",\n    allowFullScreen: \"\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"With Lerp\"), \": Here the new ball takes its position smoothhly and the balls behind are also moved in a smooth manner.\"), mdx(\"iframe\", {\n    src: \"https://gfycat.com/ifr/DescriptiveGiddyIbadanmalimbe\",\n    width: \"950px\",\n    height: \"500px\",\n    frameBorder: \"0\",\n    allowFullScreen: \"\"\n  }), mdx(\"h2\", null, \"How to Lerp in Unity3D\"), mdx(\"p\", null, \"In Unity there are multiple Lerp API available to use but they all extend on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mathf.Lerp\"), \". Lerp takes 3 parameters start, end and percentage values.\\nFor example to move a Unity GameObject from Postion A to B one can use Vector3.Lerp API.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"object.transform.position = Vecto3.Lerp(A, B, t);\\n\")), mdx(\"p\", null, \"Here \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" is the percentage variables which calculates the percentage of path to be traversed. It takes values from 0 to 1.\"), mdx(\"p\", null, \"Read more at: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.unity3d.com/ScriptReference/Vector3.Lerp.html\"\n  }), \"https://docs.unity3d.com/ScriptReference/Vector3.Lerp.html\")), mdx(\"h2\", null, \"What is actually happening\"), mdx(\"p\", null, \"The output of Lerp depends based on the following cases for each frame.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Change only t value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Change of the parameter A or B or both\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Change in all the values i.e A, B and t.\")), mdx(\"p\", null, \"So to clearly understand how lerp works lets dicuss these three cases. But i think the first case is very important to understand so read carefully.\"), mdx(\"h3\", null, \"Case 1: Change only t value\"), mdx(\"p\", null, \"If you have read the official docs for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vector3.Lerp\"), \" (link above) you can see the example provided calculates a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" value for each update. So the only parameter changing here is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \". lets see how this effects the output.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class ExampleClass : MonoBehaviour\\n{\\n    // Transforms to act as start and end markers for the journey.\\n    public Transform startMarker;\\n    public Transform endMarker;\\n\\n    // Movement speed in units/sec.\\n    public float speed = 1.0F;\\n\\n    // Time when the movement started.\\n    private float startTime;\\n\\n    // Total distance between the markers.\\n    private float journeyLength;\\n\\n    void Start()\\n    {\\n        // Keep a note of the time the movement started.\\n        startTime = Time.time;\\n\\n        // Calculate the journey length.\\n        journeyLength = Vector3.Distance(startMarker.position, endMarker.position);\\n    }\\n\\n    // Follows the target position like with a spring\\n    void Update()\\n    {\\n        // Distance moved = time * speed.\\n        float distCovered = (Time.time - startTime) * speed;\\n\\n        // Fraction of journey completed = current distance divided by total distance.\\n        float fracJourney = distCovered / journeyLength;\\n\\n        // Set our position as a fraction of the distance between the markers.\\n        transform.position = Vector3.Lerp(startMarker.position, endMarker.position, fracJourney);\\n    }\\n}\\n\")), mdx(\"p\", null, \"source: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.unity3d.com/ScriptReference/Vector3.Lerp.html\"\n  }), \"https://docs.unity3d.com/ScriptReference/Vector3.Lerp.html\")), mdx(\"p\", null, \"Here intially we set the time at which it starts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"startTime\"), \", total distance to travel \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"journeyLength\"), \". Also note that the start and end positions are not changed. This initial information can be used to traverse the path between start and end points and set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" to one which will increase from 0 to 1 each frame. The faster your increment the value the sooner you will reach the end position.\"), mdx(\"p\", null, \"And one way of doing this is to calculate the ratio i.e journey distane of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"distCovered\"), \" to total distance \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"journeyLength\"), \" at each frame which will be used as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \". Lets take a simple example to understand this. Say we have two points in one dimension at units 0 and 10. And we want to lerp between these two points.\"), mdx(\"p\", null, \"Here total distance is 10. Also lets assume that at each frame the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" value is incrementd by 0.1 upon calculation. Which would mean 10%. So at each frame travel distance is incremented by 10% i.e 10% , 20% , 30% \\u2026 100%. But carefully \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"note that in this case the percentage will be applied to the total distane but not to the remaining distance\"), \". This is the key point to observe here. This is beacuse we are not changing the starting point.\"), mdx(\"p\", null, \"See below table to understand the progression for the above example for above mentioned t values.\"), mdx(\"p\", null, \"here we have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" , \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t * totalDistance\"), \", next positon for that frame\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"0.1 => 0.1 * 10 => 1\\n0.2 => 0.2 * 10 => 2\\n.\\n.\\n.\\n0.9 => 0.9 * 10 => 9\\n1.0 -> 1.0 * 10 => 10\\n\")), mdx(\"p\", null, \"This can be easily mapped to the 2D and 3D Vectors. Just by assuming that the above points are (0,0) and (0,10) for 2D and (0,0,0) and (0,0,10).\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Different way to calculate t :\"), \"\\nAlso t can be calculated in other ways too, say we want to complete the journey in a certain amount of time then we can have a function which calculates the t by taking ratio of currentTime / targetTime, where currentTime is initialized to 0 and each frame it is set as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentTime += Time.deltaTime\"), \".\"), mdx(\"p\", null, \"In the below code we want the journey to complete in 1 sec i.e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"targetTime = 1\"), \";\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class ExampleClass : MonoBehaviour\\n{\\n    // Transforms to act as start and end markers for the journey.\\n    public Transform startMarker;\\n    public Transform endMarker;\\n\\n    // Move to the target in one sec.\\n    public float targetTime = 1.0F;\\n\\n    // Total distance between the markers.\\n    private float currentTime;\\n\\n    void Start()\\n    {\\n        // Marks the start time when the movement starts\\n        currentTime = 0;\\n    }\\n\\n    // Follows the target position like with a spring\\n    void Update()\\n    {\\n        currentTime += Time.deltaTime;\\n\\n        // Fraction of journey completed = current distance divided by total distance.\\n        float timeFrac = currentTime / targetTime;\\n\\n        // Set our position as a fraction of the distance between the markers.\\n        transform.position = Vector3.Lerp(startMarker.position, endMarker.position, timeFrac);\\n    }\\n}\\n\")), mdx(\"h3\", null, \"Case 2: Change parameter A or B or both\"), mdx(\"p\", null, \"I feel that most of the beginners starting with lerp might have used this way to Lerp and thus getting unexpected results.\"), mdx(\"p\", null, \"Usually when a object is moved we set the start value i.e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" to the current position of the object. Doing this will effectively change the position calculated for the frame in which the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" is changed because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" is already incremented and the calculation usually happens based on fixed start and end.\"), mdx(\"p\", null, \"So if we have already travelled x distance from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" and changed the start value from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" to the current position then the next position calculated will be based on current Positon and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" values.\"), mdx(\"p\", null, \"To understand this lets take the example from above.\"), mdx(\"p\", null, \"Say after we get t = 0.2 the position is 2 and at this instant we set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" to 2.\\nThen we have a totalDistance value = 10 -2 = 8 but not 10.\\nSo lets calculate the next position based on above changes at t= 0.3\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"at t = 0.3\\nnextPos = t * remainingDistance = 0.3 * 8 = 2.4\\n\")), mdx(\"p\", null, \"So the next positon will be incremented by 2.4 units.\"), mdx(\"p\", null, \"Now lets check this value with that of the above case where start \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" is not changed and totalDistance is still 10.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"at t =\\nnextPos = t * totalDistance = 0.3 * 10 = 3\\n\")), mdx(\"p\", null, \"So in this case when we changed the start value i.e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" the calculation takes the remaining distance into consideration.\\nThe same thing will happen if the end value B or both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" are changed.\"), mdx(\"h3\", null, \"Case 3: Change all the parameters\"), mdx(\"p\", null, \"What if you want to change the position and also get the results same as that of the case 1.\\nWhat can we do to get the value same as that of the case 1 even if we change the start \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" and end \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \".\\nWe can do that by adjusting t value.\"), mdx(\"h2\", null, \"What more can be done\"), mdx(\"p\", null, \"By adjusting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" value one can produce ease results like the ones mentioned \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://easings.net/\"\n  }), \"here\"), \". I hope this post was helpful to understand how lerp works and how the parameters effect the output.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Why do we need Lerp in the first place Linear Interpolation or Lerping is a way to change value smoothly over time between two values. You…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/unity-3-d-understanding-what-lerp-does-and-how","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574","3325520806"]}